<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Names</title>
</head>

<body>
    <fieldset>
        <legend>Words</legend>
        <input type="button" id="btnWord" name="btnWord" value="Word" data-key="word" /> 
        <label for="btnWord" >Generate a word using English phonotactics</label>
        <hr/>
        <input type="button" id="btnWord1" name="btnWord1" value="One-Syllable Word" data-key="word.1sylword" /> 
        <label for="btnWord1" >Generate a one-syllable word using English phonotactics</label>
        <hr/>
        <input type="button" id="btnWord2" name="btnWord2" value="One-Syllable Word" data-key="word.2sylword" /> 
        <label for="btnWord2" >Generate a two-syllable word using English phonotactics</label>
    </fieldset>
    <fieldset>
        <legend>Human Names</legend>
        <input type="button" id="btnHuman" name="btnHuman" value="Human Name" data-key="human" /> 
        <label for="btnHuman" >Generate a human name</label>
        <hr/>
        <input type="button" id="btnHumanFemale" name="btnHumanFemale" value="Human Female" data-key="human.femalefirstname" /> 
        <label for="btnHumanFemale" >Generate a female given name</label>
        <span>&nbsp;</span>
        <input type="button" id="btnHumanMale" name="btnHumanMale" value="Human Male" data-key="human.malefirstname" /> 
        <label for="btnHumanMale" >Generate a male given name</label>
        <hr/>
        <input type="button" id="btnHumanLName" name="btnHumanLName" value="Human Surname" data-key="human.lastname" /> 
        <label for="btnHumanLName" >Generate a human surname</label>
    </fieldset>
    <fieldset>
        <legend>System Names</legend>
        <input type="button" id="btnSystem" name="btnSystem" value="System" data-key="system" /> 
        <label for="btnSystem" >Generate a solar system name</label>
        <hr/>
        <input type="button" id="btnSystemwithoutinventedwords" name="btnSystemwithoutinventedwords" value="System Without Invented Words" data-key="system.systemwithoutinventedwords" /> 
        <label for="btnSystemwithoutinventedwords" >Generate a solar system name without invented words</label>
    </fieldset>
    <fieldset>
        <legend>Ship Names</legend>
        <input type="button" id="btnShip" name="btnShip" value="Ship" data-key="ship" /> 
        <label for="btnShip" >Generate a starship name</label>
        <hr/>
        <input type="button" id="btnShipYacht" name="btnShipYacht" value="Punny Ship" data-key="ship.yacht" /> 
        <label for="btnShipYacht" >Generate a punny starship name</label>
    </fieldset>
    <script>
        (function (global) {
            if (typeof global.JSON == "undefined" || !global.JSON) {
                global.JSON = {};
            }

            global.JSON.minify = function JSON_minify(json) {

                var tokenizer = /"|(\/\*)|(\*\/)|(\/\/)|\n|\r/g,
                    in_string = false,
                    in_multiline_comment = false,
                    in_singleline_comment = false,
                    tmp, tmp2, new_str = [], ns = 0, from = 0, lc, rc,
                    prevFrom
                    ;

                tokenizer.lastIndex = 0;

                while (tmp = tokenizer.exec(json)) {
                    lc = RegExp.leftContext;
                    rc = RegExp.rightContext;
                    if (!in_multiline_comment && !in_singleline_comment) {
                        tmp2 = lc.substring(from);
                        if (!in_string) {
                            tmp2 = tmp2.replace(/(\n|\r|\s)+/g, "");
                        }
                        new_str[ns++] = tmp2;
                    }
                    prevFrom = from;
                    from = tokenizer.lastIndex;

                    // found a " character, and we're not currently in
                    // a comment? check for previous `\` escaping immediately
                    // leftward adjacent to this match
                    if (tmp[0] == "\"" && !in_multiline_comment && !in_singleline_comment) {
                        // perform look-behind escaping match, but
                        // limit left-context matching to only go back
                        // to the position of the last token match
                        //
                        // see: https://github.com/getify/JSON.minify/issues/64
                        tmp2 = lc.substring(prevFrom).match(/\\+$/);

                        // start of string with ", or unescaped " character found to end string?
                        if (!in_string || !tmp2 || (tmp2[0].length % 2) == 0) {
                            in_string = !in_string;
                        }
                        from--; // include " character in next catch
                        rc = json.substring(from);
                    }
                    else if (tmp[0] == "/*" && !in_string && !in_multiline_comment && !in_singleline_comment) {
                        in_multiline_comment = true;
                    }
                    else if (tmp[0] == "*/" && !in_string && in_multiline_comment && !in_singleline_comment) {
                        in_multiline_comment = false;
                    }
                    else if (tmp[0] == "//" && !in_string && !in_multiline_comment && !in_singleline_comment) {
                        in_singleline_comment = true;
                    }
                    else if ((tmp[0] == "\n" || tmp[0] == "\r") && !in_string && !in_multiline_comment && in_singleline_comment) {
                        in_singleline_comment = false;
                    }
                    else if (!in_multiline_comment && !in_singleline_comment && !(/\n|\r|\s/.test(tmp[0]))) {
                        new_str[ns++] = tmp[0];
                    }
                }
                new_str[ns++] = rc;
                return new_str.join("");
            };
        })(
            // attempt to reference the global object
            typeof globalThis != "undefined" ? globalThis :
                typeof global != "undefined" ? global :
                    typeof window != "undefined" ? window :
                        typeof self != "undefined" ? self :
                            typeof this != "undefined" ? this :
                                {}
        );

        var xhr = new XMLHttpRequest();
        xhr.open("GET", "names.jsonc");
        xhr.addEventListener("load", function loadStrings(evt) {
            var rawJson = xhr.responseText;
            window.stringtemplates = getWeightedPatternsFromJSON({}, JSON.parse(JSON.minify(rawJson)));
            addEventListeners();
        });
        xhr.send();
        function addEventListeners(){
            var buttons = document.querySelectorAll("input[data-key]");
            for(var i = 0, len = buttons.length; i < len; i++){
                var button = buttons[i];
                button.addEventListener("click",function(e){
                    var key = e.srcElement.getAttribute("data-key");
                    var value = getRandomName(key);
                    var btnName = e.srcElement.getAttribute("name");
                    var label = document.querySelector("label[for=\""+btnName+"\"]");
                    label.innerText = addCaps(value);
                });
            }
        }
        function getRandomName(key) {
            var templates = window.stringtemplates[key];
            var template = templates[(templates.length * Math.random()) >>> 0];
            var phrases = unpackStringTemplate(template); // convert string into array of phrase objects with child segments
            window.unpackStringTemplate = unpackStringTemplate;
            if (!window.UnpackedStringTemplates) { window.UnpackedStringTemplates = { names: {} } };
            window.UnpackedStringTemplates.names[key] = phrases;
            var phrase = phrases[(phrases.length * Math.random()) >>> 0];
            var currentText = "";
            for (var i = 0, len = phrase.length; i < len; i++) { // process each segment of the selected phrase
                var segment = phrase[i];
                if (segment.text) {
                    currentText += segment.text;
                } else if (segment.reference) {
                    currentText += getRandomName(segment.reference);
                } else if (segment.references) {
                    currentText += getRandomName(segment.references[(segment.references.length * Math.random()) >>> 0]);
                }
            }
            return currentText;
        }
        function addCaps(text) {
            var capitalizedString = "";
            var lastCharacter = null, currCharacter = " ";
            for (var i = 0, len = text.length; i < len; i++) {
                lastCharacter = currCharacter;
                currCharacter = text[i];
                if (lastCharacter === " " || lastCharacter === "-") {
                    capitalizedString += currCharacter.toUpperCase();
                } else {
                    capitalizedString += currCharacter;
                }
            }
            return capitalizedString;
        }
        function unpackStringTemplate(template) {
            var bracketDepth = 0;
            var phraseArray = [];
            var currentString = "";
            // build outer array
            for (var i = 0, len = template.length; i < len; i++) {
                var character = template[i];
                if (character === "{") {
                    bracketDepth += 1;
                    currentString += character;
                } else if (character === "}") {
                    bracketDepth -= 1;
                    currentString += character;
                } else if (character === "|" && bracketDepth === 0) {
                    phraseArray.push(currentString);
                    currentString = "";
                } else {
                    currentString += character;
                }
            }
            if (currentString.length > 0) {
                phraseArray.push(currentString);
            }
            // for each phrase in the array, get the segments
            var isTextSegment = true, isRefSegment = false, isRefArray = false;
            currentString = "", bracketDepth = 0;
            var returnArray = []; // this array holds the phrases
            for (var i = 0, len = phraseArray.length; i < len; i++) {
                var phrase = phraseArray[i];
                var currArr = []; // this array holds the segments for a phrase
                var refArr = []; // this object holds a references segment under construction;
                for (var j = 0, jlen = phrase.length; j < jlen; j++) {
                    var character = phrase[j];
                    if (character === "{") {
                        if (currentString.length > 0) {
                            if (isTextSegment) {
                                currArr.push({ text: currentString });
                            }
                        }
                        isTextSegment = false;
                        isRefSegment = true;
                        currentString = "";
                    } else if (character === "}") {
                        if (isRefSegment) {
                            currArr.push({ reference: currentString });
                            currentString = "";
                            isRefSegment = false;
                            currentString = "";
                        } else if (isRefArray) {
                            refArr.push(currentString);
                            currentString = "";
                            currArr.push({ references: refArr });
                            isRefArray = false;
                            refArr = [];
                        }
                        currentString = "";
                    } else if (character === "|") {
                        if (isRefSegment) {
                            isRefArray = true;
                            isRefSegment = false;
                            refArr.push(currentString);
                            currentString = "";
                        } else if (isRefArray) {
                            refArr.push(currentString);
                            currentString = "";
                        }
                    } else {
                        if (!isRefSegment && !isRefArray) {
                            isTextSegment = true;
                        }
                        currentString += character;
                    }
                }
                if (currentString.length > 0) {
                    if (isTextSegment) {
                        currArr.push({ text: currentString });
                        currentString = "";
                    }
                }
                returnArray.push(currArr);
            }
            return returnArray;
        }
        function getWeightedPatternsFromJSON(returnObj, obj) {
            for (var key in obj) {
                if (key === "patterns") { continue; }
                var collection = obj[key];
                var collectionIsArray = collection.constructor === Array;
                returnObj[key] = getWeightedPatternsFromJSONSegment(collection);
                if (!collectionIsArray) {
                    for (var subkey in collection) {
                        if (subkey === "patterns") { continue; }
                        var subcollection = collection[subkey];
                        returnObj[key + "." + subkey] = getWeightedPatternsFromJSONSegment(subcollection);
                    }
                }
            }
            return returnObj;
        }
        function getWeightedPatternsFromJSONSegment(collection) {
            var weightedPatterns = [];
            if (typeof collection.patterns !== "undefined") {

                var patterns = collection.patterns;
                for (var i = 0, len = patterns.length; i < len; i++) {
                    var pattern = patterns[i];
                    var weight = 1, isString = pattern.constructor === String;
                    var patternText = "";
                    if (!isString) {
                        if (pattern.weight) {
                            weight = pattern.weight;
                        }
                        if (pattern.format) {
                            patternText = pattern.format
                        }
                    } else { // look for shorthand of weight:template in string
                        var indexOfColon = pattern.indexOf(":");
                        if (indexOfColon > 0) {
                            var preColonText = pattern.substring(0, indexOfColon);
                            var number = +(preColonText);
                            if (number >= 0) {
                                weight = number;
                                patternText = pattern.substring(indexOfColon + 1);
                            } else {
                                patternText = pattern;
                            }
                        } else {
                            weight = 1;
                            patternText = pattern;
                        }
                    }
                    for (var j = 0; j < weight; j++) {
                        weightedPatterns.push(patternText);
                    }
                }
            } else if (collection.constructor === Array) {
                for (var i = 0, len = collection.length; i < len; i++) {
                    var pattern = collection[i];
                    var weight = 1, isString = pattern.constructor === String;
                    var patternText = "";
                    if (!isString) {
                        if (pattern.weight) {
                            weight = pattern.weight;
                        }
                        if (pattern.format) {
                            patternText = pattern.format
                        }
                    } else { // look for shorthand of weight:template in string
                        var indexOfColon = pattern.indexOf(":");
                        if (indexOfColon > 0) {
                            var preColonText = pattern.substring(0, indexOfColon);
                            var number = +(preColonText);
                            if (number >= 0) {
                                weight = number;
                                patternText = pattern.substring(indexOfColon + 1);
                            } else {
                                patternText = pattern;
                            }
                        } else {
                            weight = 1;
                            patternText = pattern;
                        }
                    }
                    for (var j = 0; j < weight; j++) {
                        weightedPatterns.push(patternText);
                    }
                }
            }
            return weightedPatterns;
        }
    </script>
</body>

</html>